Дан массив нужно найти k-ый по счету наибольший элемент.

Есть три основных подхода:
1) сортировка n logn
2) max-heap размера k (Priority Queue) n logn
3) quickselect алогритм n-n^2

для quickselect мы выбираем пивотный pivot и размещаем элементы меньше слева от него и элементы больше справа, а затем так же повторяем с нужной нам половиной рекурсивно. Тут удобно делть in-place замену элментов, нужно сделать swap(pivot, right) т.е свапнуть пивот с последним элементом, а затем хранить один указать на место куда записывать следующий элемен меньше пивота и проходиться по списку, если элемент больше пивота то свапать его с с элементом на который указывает первый указатель.

