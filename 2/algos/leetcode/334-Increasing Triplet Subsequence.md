## Возврастающий триплет

Смысл задачи в том чтобы узнать есть ли в массиве nums такие три элемента с индексами i < j < k что nums[i] < nums[j] < nums[k].
Задача решается за O(n) по времени.

Идея в том чтобы идти по массиву и хранить два минимальных элемента. Если находится новый элемент который меньше чем два этих, то реплет триплет найден.
При этом этом второе минимальное число является реальным, а вот первое просто является оптимальным стратом для всех последующих возможных триплетов.
При этом мы знаем что даже при смене первого числа на другое, старое первое число все ещё лежит между новым первым и старым вторым. Поэтому
алгоритм учитывает все следующие старты триплетов которые меньше но и при нахождении числа больше чем второе минимальное триплет сразу будет найден.

``` Java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        if (nums.length < 3) return false;
        Integer first = Integer.MAX_VALUE;
        Integer second = Integer.MAX_VALUE;

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] < first) {
                first = nums[i];
            } else if (nums[i] < second && nums[i] > first) {
                second = nums[i];
            } else if (nums[i] > second){
                return true;
            }
        }

        return false;
    }
}
```