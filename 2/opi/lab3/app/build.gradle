/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.7/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    id 'java'
}

repositories {

    mavenCentral()
}

dependencies {
    
    compileOnly 'jakarta.servlet:jakarta.servlet-api:6.0.0'

    compileOnly 'jakarta.faces:jakarta.faces-api:3.0.0'

    compileOnly 'jakarta.enterprise:jakarta.enterprise.cdi-api:4.0.1'

    implementation 'org.hibernate:hibernate-core:5.6.0.Final'
    implementation 'org.postgresql:postgresql:42.3.1'
    implementation 'javax.xml.bind:jaxb-api:2.3.1'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.2'

    testImplementation 'org.testcontainers:junit-jupiter:1.16.3'
    testImplementation 'org.testcontainers:postgresql:1.16.3'
    implementation 'org.testcontainers:postgresql:1.16.3'

    testImplementation 'org.postgresql:postgresql:42.2.23'

    implementation 'javax.validation:validation-api:2.0.1.Final'

    implementation 'org.primefaces:primefaces:11.0.0:jakarta'

    implementation 'javax.xml.bind:jaxb-api:2.3.1'

    // https://mvnrepository.com/artifact/xerces/xercesImpl
    implementation group: 'xerces', name: 'xercesImpl', version: '2.12.2'

}


def javacExecutable = project.javacExecutable

task compile {

    doFirst {
        file("${buildDir}/classes").mkdirs()
    }
    
    doLast {
    
        def srcDir = file('src/main/java')
        def classesDir = file("${buildDir}/classes/java/main")
        
        def files = fileTree(dir: srcDir, includes: ['**/*.java']).files.collect { it.absolutePath }
        
        println 'Spisok faylov:'
        files.each { filePath ->
            println filePath
        }
        
        if (files.isEmpty()) {
            throw new GradleException('Ne ndaydeno faylov.')
        }

        def command = [
            javacExecutable,
            '-d', classesDir.absolutePath,
            '-sourcepath', srcDir.absolutePath,
            '-classpath', configurations.compileClasspath.asPath
        ] + files
        
        def proc = command.execute()
        proc.in.eachLine { line -> println line }
        proc.err.eachLine { line -> println "ERROR: $line" }
        proc.waitFor()
        
        if (proc.exitValue() != 0) {
            throw new GradleException("Compilation failed with exit value: ${proc.exitValue()}")
        }
        
        println 'Comp finished.'
    }
}

def jarName = project.jarName

def mainClass = project.mainClass

import java.text.SimpleDateFormat

def getDate() {
    new SimpleDateFormat("yyyyMMddHHmmss").format(new Date())
}

task createJar(type: Jar) {
    manifest {
        attributes(
            'Implementation-Title': jarName,
            'Implementation-Version': getDate(),
            'Main-Class': mainClass
        )
    }
    
    from(file("${buildDir}/classes/java/main")) {
        into '/'
    }
    archiveBaseName.set(jarName)
    archiveVersion.set(jarVersion)
    archiveClassifier.set('')

    destinationDirectory.set(file("$buildDir/libs"))
}

task buildJar {
    dependsOn compile
    finalizedBy createJar
}

task cleanAll(type: Delete) {
    delete buildDir
}

test {
    useJUnitPlatform()
}


import javax.xml.parsers.DocumentBuilder
import javax.xml.parsers.DocumentBuilderFactory
import org.w3c.dom.Document
import org.xml.sax.InputSource
import java.io.File

task validateXmlSyntax {
    doLast {
        
        def dbFactory = DocumentBuilderFactory.newInstance()
        def dBuilder = dbFactory.newDocumentBuilder()

        def xmlFiles = fileTree(dir: 'src/main/resources', include: '**/*.xml')

        xmlFiles.each { File xmlFile ->
            try {
            
                Document doc = dBuilder.parse(xmlFile)
                println "Valid XML: ${xmlFile}"
            } catch (Exception e) {
                
                println "Invalid XML in file ${xmlFile}: ${e.message}"
            }
        }
    }
}


import java.nio.charset.Charset
import java.nio.file.Files
import java.nio.file.Paths
import java.util.Properties
ext {
    sourceEncoding = 'UTF-8'
    targetEncoding = 'UTF-8'
}

task native2Ascii {
    doLast {
        def sourceDir = file('src/main/resources')
        def targetDir = file("$buildDir/processed-resources")
        if (!targetDir.exists()) {
            targetDir.mkdirs()
        }

        def propsFiles = fileTree(dir: sourceDir, include: '**/*.properties')
        propsFiles.each { File propFile ->
            def sourcePath = propFile.toPath()
            def targetPath = targetDir.toPath().resolve(propFile.getName())

            def reader = Files.newBufferedReader(sourcePath, Charset.forName(sourceEncoding))
            def writer = Files.newBufferedWriter(targetPath, Charset.forName(targetEncoding))

            try {
                def props = new Properties()
                props.load(reader)
                props.store(writer, null)
            } finally {
                reader.close()
                writer.close()
            }
            println "Converted ${propFile} to ASCII format."
        }
    }
}

task generateJavadoc(type: Javadoc) {
    source = sourceSets.main.allJava
    classpath = configurations.compileClasspath
    destinationDir = file("$buildDir/docs/javadoc")
    options.memberLevel = JavadocMemberLevel.PUBLIC
    options.author = true
    options.version = true
    options.links("https://docs.oracle.com/javase/8/docs/api/")
}

import java.security.MessageDigest

task addHashesToManifest {
    doLast {
        def manifestFile = file("$buildDir/tmp/createJar/MANIFEST.MF")
        def mfContent = manifestFile.text

        // Вычисляем хэши
        def md5 = MessageDigest.getInstance("MD5")
        def sha1 = MessageDigest.getInstance("SHA-1")

        sourceSets.main.allJava.each { File file ->
            def bytes = file.bytes
            md5.update(bytes)
            sha1.update(bytes)
        }

        // Конвертируем байты в шестнадцатеричный формат
        def md5sum = md5.digest().collect { String.format("%02x", it) }.join('')
        def sha1sum = sha1.digest().collect { String.format("%02x", it) }.join('')

        // Добавляем хэши в MANIFEST.MF
        mfContent += "MD5-Digest: $md5sum\n"
        mfContent += "SHA1-Digest: $sha1sum\n"

        manifestFile.text = mfContent
    }
}

task createDocArchive(type: Jar) {
    from generateJavadoc
    from addHashesToManifest
    archiveBaseName = 'ProjectDocumentation'
    archiveVersion = '1.0'
    destinationDirectory = file("$buildDir/libs")
    manifest {
        attributes(
            'Name': 'Project Documentation',
            'MD5-Digest': '',
            'SHA1-Digest': ''
        )
    }
}

createDocArchive.dependsOn generateJavadoc, addHashesToManifest


import java.util.Properties

// Загрузка настроек окружения
def envProps = new Properties()
file('env.properties').withInputStream { stream ->
    envProps.load(stream)
}

// Настройка JAVA_HOME для использования специфической версии Java
def javaExec = "${envProps['javaHome']}/bin/java"

// Задача для запуска приложения
task runApp(type: Exec) {
    // Разделение строки аргументов JVM на массив
    def jvmArgs = envProps['jvmArgs'].split(' ')

    // Командная строка для запуска Java-программы
    commandLine javaExec
    args '-cp', sourceSets.main.runtimeClasspath.getAsPath()
    args jvmArgs
    args mainClass
    standardOutput = new ByteArrayOutputStream()

    doLast {
        // Вывод результатов выполнения
        println "Output: " + standardOutput.toString()
    }
}

task modifySources {
    doLast {
        def props = new Properties()
        file('replace.properties').withInputStream { props.load(it) }

        def srcDir = file('src/main/java')
        def destDir = file("$buildDir/modified-sources")

        if (!destDir.exists()) {
            destDir.mkdirs()
        }

        srcDir.eachFileRecurse { file ->
            if (file.name.endsWith('.java')) {
                def content = file.text
                content = content.replaceAll(props.getProperty("oldVar"), props.getProperty("newVar"))

                // Создаем новый путь и проверяем существование директорий
                def newPath = file.path.replace(srcDir.path, destDir.path)
                def newFile = new File(newPath)

                // Создаем директории для нового файла, если они еще не существуют
                if (!newFile.parentFile.exists()) {
                    newFile.parentFile.mkdirs()
                }

                // Записываем измененное содержимое в файл
                newFile.text = content
            }
        }
    }
}


task prepareAltSources {
    dependsOn modifySources
    doLast {
        // Перенастройка исходников для компиляции
        compileJava.source = fileTree(dir: "$buildDir/modified-sources", includes: ['**/*.java'])
    }
}

task buildAltJar {
    dependsOn prepareAltSources, buildJar
}