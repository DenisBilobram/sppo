# Assignment: ELF64 file loader

Лабораторная работа: Загрузка ELF64 файла

# Подготовка

- Прочитайте документацию по формату PE файла: https://www.uclibc.org/docs/elf-64-gen.pdf
- Ознакомьтесь с правилами MISRA C, доступным начиная со страницы 12 в http://easyelectronics.ru/files/Book/misra_c_rus.pdf

# Задание

Необходимо реализовать чтение и загрузку в виртуальную память файла в формате ELF64 и передачу управления на стартовый адрес указанной секции.
Формат использования утилиты следующий:

```C
./elf64-loader <source-elf64-file> <section-name>
```

Аргументы:
  - `<source-elf64-file>` - имя файла в формате ELF64
  - `<section-name>` - имя секции, стартовому адресу которой необходимо передать управление после загрузки ELF64 файла в виртуальную память.

Требования к реализации:
  - Код размещается в директории `solution/src`, заголовочные файлы ищутся в `solution/include`;
  - Код должен быть написан аккуратно, читаемо и разбит на функции (минимум);
  - Ввиду требований к реализации, необходима поддержка GNU-совместимых компиляторов;
  - Грузиться будут только загружамые данные, хранящиеся в файле ELF64;
  - Позиционно-независимый (PIC) код из ELF64 не поддерживается;
  - Динамические библиотеки не поддерживаются;
  - В случае возникновения ошибки в ходе выполнения прогарммы, ошибку следует обработать, и, если выполнение продолжить невозможно, то надо возвращать не какое-то ненулевое число, а один из стандартных кодов ошибки:
    - Стандартные коды ошибки можно посмотеть в `/usr/include/asm-generic/errno-base.h`;
    - Если входной файл не найден, то надо вернуть `ENOENT` равный 2;
    - При ошибке ввода-вывода надо вернуть `EIO` равный 5;
    - и т.д.

На реализацию накладываются следующие ограничения (но при желании можно реализовать код, полностью по стандарту MISRA C, но данный минимум необходимо поддержать):
  - Код долнен соответсвовать стандарту C99;
  - Код должен компилироваться без ошибок или замечаний с ключами `-Wpedantic -Wall`;
  - Должны обрабатываться все нештатные ситуации и ошибки в процессе работы утилиты;
  - Запрещено использование стандартной библиотеки ввода-вывода (stdio.h);
  - Запрещено использование стандартного аллокатора памяти (`malloc`, `calloc`, и т.д.);
  - Запрещено использование стандартных функций работы со сторками (string.h);
  - Запрешено использование команд `goto` и `continue`;
  - Команда `break` может быть использована только в рамках `switch`;
  - Запрещено использование платформо-зависимых типов за исключением счеткичов (`int`) и символов (`char`);
  - Не должно быть никаких закоментированных фрагментов кода.

# ELF64 файл

ELF64 файлы используются в ОС Linux для хранения объектных и исполняемых файлов. Все заголовки ELF64 файлов доступны в заголовочном файле `elf.h`.

Формат ELF64 файла достаточно простой. Файл состоит из нескольих заголовков и данных, которые должны быть загружены в соответствующие адреса виртуальной памяти.

## Заголовок файла

Файл ELF64 начинается с заголовка, содержащего основную информацию о файле (все эти структуры и константы определены в заголовочном файле `elf.h`):

```C
typedef struct
{
  unsigned char e_ident[16]; /* ELF identification */
  Elf64_Half e_type;         /* Object file type */
  Elf64_Half e_machine;      /* Machine type */
  Elf64_Word e_version;      /* Object file version */
  Elf64_Addr e_entry;        /* Entry point address */
  Elf64_Off  e_phoff;        /* Program header offset */
  Elf64_Off  e_shoff;        /* Section header offset */
  Elf64_Word e_flags;        /* Processor-specific flags */
  Elf64_Half e_ehsize;       /* ELF header size */
  Elf64_Half e_phentsize;    /* Size of program header entry */
  Elf64_Half e_phnum;        /* Number of program header entries */
  Elf64_Half e_shentsize;    /* Size of section header entry */
  Elf64_Half e_shnum;        /* Number of section header entries */
  Elf64_Half e_shstrndx;     /* Section name string table index */
} Elf64_Ehdr;
```

После чтения заголовка обязательным условием является проверка magic number в поле идентификатора (`e_ident`). Первые четыре байла должны равняться `\x7f`, 
`E`, `L` и `F` соответственно.

В данном заголовке вас больше всего вас будут интересовать следующие поля:
- `e_phoff` - смещение на первый из программных заголовков;
- `e_phnum` - количество программных заголовков;
- `e_shoff` - смещение на первый заголовок секции;
- `e_shnum` - количество заголовков секций;
- `e_shstrndx` - индекс секции с таблицой имен секций.

Так как по заданию нам запрещено использование стандартной библиотеки ввода-вывода, то и использование функций работы с файлами (`fopen`, `fread` и т.д.) нам тоже запрещены. Вместо этого надо использовать системные функции ОС Linux, а именно `open`, `read`, `write`, `lseek` и т.д.

## Программный заголовок (Program header)

Программные заголовки находятся начиная со смещения `e_phoff`, храняшегося в основном заголовке ELF64, и содержат информацию об областях виртуальной памяти и что в них надо загрузить:

```C
typedef struct
{
  Elf64_Word  p_type;   /* Type of segment */
  Elf64_Word  p_flags;  /* Segment attributes */
  Elf64_Off   p_offset; /* Offset in file */
  Elf64_Addr  p_vaddr;  /* Virtual address in memory */
  Elf64_Addr  p_paddr;  /* Reserved */
  Elf64_Xword p_filesz; /* Size of segment in file */
  Elf64_Xword p_memsz;  /* Size of segment in memory */
  Elf64_Xword p_align;  /* Alignment of segment */
} Elf64_Phdr;
```

В данном заголовке вас больше всего вас будут интересовать следующие поля:
- `p_type` - тип сегмента, загружать в виртуальную память будем только сегменты типа `PT_LOAD`;
- `p_flags` - флаги сегмента, надо задать права на доступ к памяти в соответствии со значением флагов (`PT_X`, `PT_R`, `PT_W`);
- `p_vaddr` - стартовый адрес виртуальной памяти, куда должны быть загружены данные;
- `p_memsz` - объем виртуальной памяти, куда должны грузиться данные (он может быть больше, чем записано данных в файле);
- `p_offset` - смещение в файле, откуда надо грузить данные в виртуальную память;
- `p_memsz` - объем данных в памяти.

Для выделения сегмента в виртуальной памяти следует использовать функцию `mmap`, для установки прав на сегмент после загрузки данных пригодится функция `mprotect`. Документация на эти функции доступна в страницах `man`.

На что стоит обратить внимание во время загрузки данных в память:
- Старт диапазона виртуальной памяти может быть не кратен размеру страницы (0x1000 байт) и его необходимо будет выравнивать (флаг выравнивания в данной работе мы игнорируем);
- Размер сегмента виртуальной памяти после выравнивания стартового адреса может измениться и это тоже должно быть учтено (напрмер вместо одного блока по 0x1000 байт может придется выделить два);
- Возможна ситуация, что значения константы `MAP_ANONYMOUS` и `MAP_FIXED_NOREPLACE` не определены в GCC, но они вам нужны для корректной реализации (это происходит при компиляции в соответствии со стандартом C99, ключ компилятора `-std=c99`), тогда следует их определить:
```C
#ifndef MAP_ANONYMOUS
#define MAP_ANONYMOUS 0x20
#endif
#ifndef MAP_FIXED_NOREPLACE
#define MAP_FIXED_NOREPLACE 0x100000
#endif
```

## Заголовок секции (Section header)

Заголовки секций начинаются со смещения `e_shoff` из заголовка ELF64 файлв. Они содержат информацию об секциях и привязку секций как к виртуальной памяти, так и к файлу:

```C
typedef struct
{
  Elf64_Word  sh_name;      /* Section name */
  Elf64_Word  sh_type;      /* Section type */
  Elf64_Xword sh_flags;     /* Section attributes */
  Elf64_Addr  sh_addr;      /* Virtual address in memory */
  Elf64_Off   sh_offset;    /* Offset in file */
  Elf64_Xword sh_size;      /* Size of section */
  Elf64_Word  sh_link;      /* Link to other section */
  Elf64_Word  sh_info;      /* Miscellaneous information */
  Elf64_Xword sh_addralign; /* Address alignment boundary */
  Elf64_Xword sh_entsize;   /* Size of entries, if section has table */
} Elf64_Shdr;
```

В данном заголовке вас больше всего вас будут интересовать следующие поля:
- `sh_name` -  имя секции;
- `sh_addr` - адрес в виртуальной памяти, с которой начинается данная секция.

Вот мы наконец и нашли имя секции, которой требуется передать управление. Но, в данном поле хранится не просто имя, а смещение на начало имени (нуль-терминированной строки) относительно начала таблицы имен.

## Таблица имён (Section name string table)

Таблица имен находится по смещению секции под индексом `e_shstrndx` из основного заголовка файлов. Таблица имен содержит нуль-терминированые строки с именами.

# Система сборки и тестирования

Для сборки кода вам предоставлена система сборки на языке CMake, самим писать систему сборки не требуется.

- Если в вашей системе имеется статический анализатор `clang-tidy`, он будет запущен во время компиляции программы.
  Список проверок описан в файле `clang-tidy-checks.txt`. Вы можете добавить свои проверки в конец этого файла.
- Директория `tester` содержит набор тестов для тестирования вашей программы. Для запуска тестов используется CTest.
- Поддержана интеграция системы сборки со средами разработки CLion и Visual Studio Code.

Автоматические тесты на гитлабе запускаются в докере с образом, собранным из  https://gitlab.se.ifmo.ru/programming-languages/docker-c-test-machine и компилятором CLang.

Чтобы система сборки работала на вашей системе, вам необходимо:

### Linux и MacOS

- Компилятор (`gcc`/`clang`) и `cmake` (проверьте, что `cmake` версии 3.12 или выше)
- Если вы хотите использовать санитайзеры с GCC, установите `libasan`, `liblsan` и `libubsan` с помощью пакетного менеджера (названия могут отличаться).
- Если вы хотите использовать санитайзеры с Clang, на некоторых системах вам может понадобиться пакет `compiler-rt`.
- Если вы хотите пользоваться `clang-tidy`, установите `clang-tools-extra`.

### Windows

- Какая-либо среда разработки (CLion, Visual Studio Code)
- Подсистема WSL с GNU-совместимым компилятором для сборки и тестирования

### Инструкции по сборке и тестированию

- [Работа с терминалом](docs/Terminal.md)
- [CLion](docs/CLion.md)
- [Visual Studio Code](docs/VSCode.md)

