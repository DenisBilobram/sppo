## Paging (пейджинг) и Swapping (свопинг)

### Почему нужны Paging и Swapping?
- **Основная память всегда ограничена**:
  - Программисты стремятся использовать максимум доступной памяти.
  - В системе может быть много одновременно запущенных процессов.
- Чтобы освободить память, **блокированные** (или редко работающие) процессы могут временно **выгружаться** на диск, освобождая ОЗУ для более активных процессов.

### Paging (пейджинг)
- **Суть**: разделение памяти на **страницы** (pages) фиксированного размера.
- При нехватке памяти **неиспользуемые страницы** процесса могут быть выгружены на диск (в область подкачки — *swap space*).
- Впоследствии, когда процессу снова понадобится соответствующий участок памяти, страница **загружается обратно** (page-in).
- Это даёт **гранулированный** контроль над памятью: выгружаются лишь те куски процесса, которые не используются в данный момент.

### Swapping (свопинг)
- **Суть**: выгрузка **целиком всего** процесса (кроме минимально необходимых для системы данных) из ОЗУ на диск.
- Используется в ситуациях, когда процесс долго блокирован или критически не хватает памяти.
- При возобновлении работы весь процесс загружается обратно в память.

---

## Модель процесса с 7-ю состояниями
В дополнение к классической схеме с пятью состояниями (NEW, READY, ON CPU, WAIT, EXIT), при использовании свопинга и пейджинга зачастую вводят **ещё два «подвешенных» (suspended) состояния**: 
- **RUNNABLE/SUSPEND** (готов/подвешен)
- **WAIT/SUSPENDED** (ожидает/подвешен)

Это даёт более гибкий контроль за процессом, позволяя ОС выгружать процессы на диск и освобождать оперативную память.

### Состояния

1. **NEW (новый)**
   - Процесс создан, готовится к «допуску» (admit).

2. **RUNNABLE (ready)** 
   - Готов к выполнению, находится в памяти. Ждёт, когда планировщик назначит ЦП (dispatch).

3. **ON CPU (running)**
   - Выполняется на процессоре в пользовательском или системном режиме.

4. **WAIT (blocked)**
   - Процесс ждёт внешнее событие (например, ввод-вывод).

5. **RUNNABLE/SUSPEND** 
   - Процесс готов к выполнению, но **подвешен** и выгружен (частично или целиком) на диск:
     - Не может быть запущен немедленно, так как отсутствует в памяти.
     - Требуется **activate** (загрузка) для возвращения в *RUNNABLE*.

6. **WAIT/SUSPENDED** 
   - Процесс заблокирован и при этом **подвешен**:
     - Ожидает событие, но при этом не находится в памяти.
     - После наступления события процесс можно активировать (activate), но сначала нужно загрузить его в память.

7. **EXIT**
   - Процесс завершён. ОС освобождает ресурсы.

### Основные переходы
- **admit**: из *NEW* в *RUNNABLE* или, в некоторых системах, в *RUNNABLE/SUSPEND* (если нет места в памяти).
- **dispatch**: из *RUNNABLE* в *ON CPU*.
- **time-out** (или другое прерывание): из *ON CPU* обратно в *RUNNABLE*.
- **event wait**: из *ON CPU* в *WAIT*.
- **event occurs**: из *WAIT* обратно в *RUNNABLE*, а из *WAIT/SUSPENDED* в *RUNNABLE/SUSPEND*.
- **suspend**: может переводить 
  - *RUNNABLE* → *RUNNABLE/SUSPEND* (если нужен свопинг) 
  - *WAIT* → *WAIT/SUSPENDED* (заблокированный процесс подгружается на диск).
- **activate**: переводит 
  - *RUNNABLE/SUSPEND* → *RUNNABLE* 
  - *WAIT/SUSPENDED* → *WAIT* (возвращение в память).
- **release**: из *ON CPU* в *EXIT* (процесс завершён).

